import PDFDocument from "pdfkit";

function titleCase(s) {
  return String(s || "")
    .replace(/([A-Z])/g, " $1")
    .replace(/_/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .replace(/^./, (c) => c.toUpperCase());
}

function isObject(v) {
  return v && typeof v === "object" && !Array.isArray(v);
}

function formatValue(value) {
  if (value === null || value === undefined || value === "") return "-";
  if (typeof value === "boolean") return value ? "Yes" : "No";
  return String(value);
}


function isEmptyValue(value) {
  if (value === null || value === undefined) return true;
  if (typeof value === "string" && value.trim() === "") return true;
  if (Array.isArray(value)) return value.length === 0 || value.every(isEmptyValue);
  if (isObject(value)) return Object.values(value).every(isEmptyValue);
  return false;
}

function ensureSpace(doc, neededHeight) {
  const bottom = doc.page.height - doc.page.margins.bottom;
  if (doc.y + neededHeight > bottom) {
    doc.addPage();
    return true;
  }
  return false;
}

function drawHeader(doc, meta) {
  const { title, subtitleLeft, subtitleRight } = meta;
  const x = doc.page.margins.left;
  const y = doc.page.margins.top;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  // Top accent bar
  doc.save();
  doc.rect(x, y - 25, w, 8).fill("#0f172a");
  doc.restore();

  doc.fillColor("#0f172a").font("Helvetica-Bold").fontSize(18).text(title, x, y, {
    width: w,
    align: "left",
  });

  doc.moveDown(0.35);

  doc.fillColor("#334155").font("Helvetica").fontSize(10);
  doc.text(subtitleLeft || "", { width: w, continued: true });
  doc.text(subtitleRight || "", { width: w, align: "right" });

  doc.moveDown(0.8);
  doc.moveTo(x, doc.y).lineTo(x + w, doc.y).strokeColor("#CBD5E1").stroke();
  doc.moveDown(0.8);
}

function drawFooter(doc, pageNum) {
  const x = doc.page.margins.left;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;
  // IMPORTANT: PDFKit will create a *new page* if we try to draw below the
  // content area bottom boundary (page.height - margins.bottom).
  // Keep the footer safely inside the content area.
  const y = doc.page.height - doc.page.margins.bottom - 14;

  doc.save();
  doc.fillColor("#64748B").font("Helvetica").fontSize(9);
  doc.text("Generated by SmartPortal", x, y, { width: w, align: "left" });
  doc.text(`Page ${pageNum}`, x, y, { width: w, align: "right" });
  doc.restore();
}

function drawStepHeader(doc, stepIndex, title) {
  const x = doc.page.margins.left;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  ensureSpace(doc, 46);

  const y = doc.y;

  // Dark rounded bar
  doc.save();
  doc.roundedRect(x, y, w, 30, 8).fill("#0f172a");
  doc.restore();

  doc.save();
  doc.fillColor("#E2E8F0").font("Helvetica-Bold").fontSize(10);
  doc.text(`STEP ${stepIndex}`, x + 12, y + 8, { width: 70 });
  doc.fillColor("#FFFFFF").font("Helvetica-Bold").fontSize(12);
  doc.text(title, x + 82, y + 7, { width: w - 92 });
  doc.restore();

  doc.y = y + 38;
}

function cloneJson(v) {
  try {
    return JSON.parse(JSON.stringify(v));
  } catch {
    return v;
  }
}

function prefer(...vals) {
  for (const v of vals) {
    const s = String(v ?? "").trim();
    if (s) return s;
  }
  return "";
}

function hydrateAutofillFields(appDoc) {
  // Goal: ensure server-generated PDF includes fields that the UI auto-fills,
  // even if they were not persisted in formData for some reason.
  const formData = cloneJson(appDoc?.formData || {});

  const ensureAgreementParties = (stepKey, parties) => {
    if (!stepKey) return;
    const step = formData?.[stepKey];
    if (!isObject(step)) return;

    // Support both "agreementDoc" style (parties: [..]) and simple party1/party2/party3 style
    if (Array.isArray(step.parties)) {
      const arr = step.parties;
      for (let i = 0; i < Math.min(arr.length, parties.length); i++) {
        arr[i] = arr[i] || {};
        for (const [k, v] of Object.entries(parties[i] || {})) {
          if (!String(arr[i]?.[k] ?? "").trim()) arr[i][k] = v;
        }
      }
      step.parties = arr;
      formData[stepKey] = step;
      return;
    }

    // party1/party2/party3 style
    const keys = ["party1", "party2", "party3"];
    keys.forEach((k, idx) => {
      if (!isObject(step[k])) step[k] = {};
      for (const [fk, fv] of Object.entries(parties[idx] || {})) {
        if (!String(step[k]?.[fk] ?? "").trim()) step[k][fk] = fv;
      }
    });
    formData[stepKey] = step;
  };

  // Local Individual (most common missing fields: jointCdsInstructions + declaration.iWe)
  if (String(appDoc?.formKey || "") === "local_individual") {
    // Stored keys are camelCase (clientRegistration, jointCdsInstructions, ...)
    // but the PDF renderer title-cases them. Support both.
    const cr = formData?.clientRegistration || formData?.["Client Registration"] || {};
    const decl = formData?.declaration || formData?.Declaration || {};

    const principal = cr?.principal || cr?.Principal || {};
    const joint1 = cr?.jointApplicant || cr?.["Joint Applicant"] || {};
    const joint2 = cr?.secondJointApplicant || cr?.["Second Joint Applicant"] || {};
    const jci = cr?.jointCdsInstructions || cr?.["Joint Cds Instructions"] || {};

    const principalInitials = prefer(principal?.initials, principal?.namesByInitials, principal?.Initials, principal?.["Names By Initials"]);
    const joint1Initials = (joint1?.enabled || joint1?.Enabled)
      ? prefer(joint1?.initials, joint1?.namesByInitials, joint1?.Initials, joint1?.["Names By Initials"])
      : "";
    const joint2Initials = (joint2?.enabled || joint2?.Enabled)
      ? prefer(joint2?.initials, joint2?.namesByInitials, joint2?.Initials, joint2?.["Names By Initials"])
      : "";
    const authorizeJointName = [joint1Initials, joint2Initials].filter(Boolean).join(" / ");

    // Fill if missing OR if the existing value looks truncated (e.g., only the first letter)
    const preferFull = (existing, desired) => {
      const ex = String(existing ?? "").trim();
      const des = String(desired ?? "").trim();
      if (!des) return ex;
      if (!ex) return des;

      // Replace if existing is clearly shorter/truncated compared to desired.
      // Common cases we've seen: "R", "S", "R S" when the desired is "R S D Piyathmal".
      const looksLikeInitialsOnly = /^[A-Za-z](?:\s+[A-Za-z])*$/.test(ex);
      if (des.length > ex.length && (ex.length <= 3 || looksLikeInitialsOnly)) return des;

      return ex;
    };

    jci.principalHolder = preferFull(jci?.principalHolder || jci?.["Principal Holder"], principalInitials || "");
    jci.firstJointHolder = preferFull(jci?.firstJointHolder || jci?.["First Joint Holder"], joint1Initials || "");
    jci.secondJointHolder = preferFull(jci?.secondJointHolder || jci?.["Second Joint Holder"], joint2Initials || "");
    jci.iName = preferFull(jci?.iName || jci?.["I Name"], principalInitials || "");
    jci.authorizeJointName = preferFull(jci?.authorizeJointName || jci?.["Authorize Joint Name"], authorizeJointName || "");
    jci.paymentsToName = preferFull(jci?.paymentsToName || jci?.["Payments To Name"], principalInitials || "");


    // If date is missing, default to application createdAt date (YYYY-MM-DD)
    if (!String(jci?.date || jci?.Date || "").trim()) {
      const d = new Date(appDoc?.createdAt || Date.now());
      const yyyy = String(d.getFullYear()).padStart(4, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      jci.date = `${yyyy}-${mm}-${dd}`;
    }

    // Declaration -> iWe
    const iWe = decl?.iWe || decl?.["I We"] || {};
    const fullName = prefer(
      principal?.namesByInitials,
      principal?.["Names By Initials"],
      [principal?.initials || principal?.Initials, principal?.surname || principal?.Surname].filter(Boolean).join(" ")
    );
    const nic = prefer(principal?.nic, principal?.Nic);
    const addr = prefer(principal?.permanentAddress, principal?.["Permanent Address"], principal?.correspondenceAddress, principal?.["Correspondence Address"]);

    if (!String(iWe?.name || iWe?.Name || "").trim()) iWe.name = fullName || "";
    if (!String(iWe?.nicNo || iWe?.["Nic No"] || "").trim()) iWe.nicNo = nic || "";
    if (!String(iWe?.address || iWe?.Address || "").trim()) iWe.address = addr || "";

    // CDS inside iWe
    const cds = iWe?.cds || iWe?.Cds || {};
    const principalCds = principal?.cds || principal?.Cds || {};
    if (!String(cds?.prefix || cds?.Prefix || "").trim()) cds.prefix = prefer(principalCds?.prefix, principalCds?.Prefix, "");
    if (!String(cds?.number || cds?.Number || "").trim()) cds.number = prefer(principalCds?.number, principalCds?.Number, "");
    iWe.cds = cds;
    decl.iWe = iWe;

    // Write back
    cr.jointCdsInstructions = jci;
    formData.clientRegistration = cr;
    formData.declaration = decl;

    // Agreement-style steps: ensure Parties are always populated from Client Registration
    const p1 = {
      name: prefer(principal?.namesByInitials, principal?.["Names By Initials"], principalInitials),
      nicNo: prefer(principal?.nic, principal?.Nic),
      address: prefer(principal?.permanentAddress, principal?.["Permanent Address"], principal?.correspondenceAddress),
    };
    const p2 = {
      name: prefer(joint1?.namesByInitials, joint1?.["Names By Initials"], joint1Initials),
      nicNo: prefer(joint1?.nic, joint1?.Nic),
      address: prefer(joint1?.permanentAddress, joint1?.["Permanent Address"], joint1?.correspondenceAddress),
    };
    const p3 = {
      name: prefer(joint2?.namesByInitials, joint2?.["Names By Initials"], joint2Initials),
      nicNo: prefer(joint2?.nic, joint2?.Nic),
      address: prefer(joint2?.residentialAddress, joint2?.["Residential Address"], joint2?.officeAddress),
    };
    ensureAgreementParties("clientAgreement", [p1, p2, p3]);
    ensureAgreementParties("creditFacility", [p1, p2, p3]);
    ensureAgreementParties("paymentInstruction", [p1, p2, p3]);
    ensureAgreementParties("directionOnline", [p1, p2, p3]);
  }



  // Foreign Individual: ensure agreement parties and common auto-filled blocks are present
  if (String(appDoc?.formKey || "") === "foreign_individual") {
    const cr = formData?.fiClientRegistration || formData?.["Fi Client Registration"] || {};
    const principal = cr?.principal || cr?.Principal || {};
    const joint1 = cr?.jointApplicant || cr?.["Joint Applicant"] || {};
    const joint2 = cr?.secondJointApplicant || cr?.["Second Joint Applicant"] || {};

    const p1 = {
      name: prefer(principal?.namesByInitials, principal?.["Names By Initials"], principal?.initials, principal?.Initials),
      passportNo: prefer(principal?.passportNo, principal?.["Passport No"]),
      address: buildPersonAddress(principal),
    };
    const j1Enabled = joint1?.enabled || joint1?.Enabled;
    const p2 = j1Enabled
      ? {
          name: prefer(joint1?.namesByInitials, joint1?.["Names By Initials"], joint1?.initials, joint1?.Initials),
          passportNo: prefer(joint1?.passportNo, joint1?.["Passport No"]),
          address: buildPersonAddress(joint1),
        }
      : { name: "", passportNo: "", address: "" };
    const j2Enabled = joint2?.enabled || joint2?.Enabled;
    const p3 = j2Enabled
      ? {
          name: prefer(joint2?.namesByInitials, joint2?.["Names By Initials"], joint2?.initials, joint2?.Initials),
          passportNo: prefer(joint2?.passportNo, joint2?.["Passport No"]),
          address: buildPersonAddress(joint2),
        }
      : { name: "", passportNo: "", address: "" };

    // fiClientAgreement uses party1/party2/party3 object style (not parties array)
    const stepKey = "fiClientAgreement";
    if (isObject(formData?.[stepKey])) {
      const step = formData[stepKey];
      if (!isObject(step.party1)) step.party1 = {};
      if (!isObject(step.party2)) step.party2 = {};
      if (!isObject(step.party3)) step.party3 = {};
      for (const [k, v] of Object.entries(p1)) if (!String(step.party1?.[k] ?? "").trim()) step.party1[k] = v;
      for (const [k, v] of Object.entries(p2)) if (!String(step.party2?.[k] ?? "").trim()) step.party2[k] = v;
      for (const [k, v] of Object.entries(p3)) if (!String(step.party3?.[k] ?? "").trim()) step.party3[k] = v;
      formData[stepKey] = step;
    }
  }

  // Foreign Corporate: keep beneficial owners array well-formed and fill some office-use defaults
  if (String(appDoc?.formKey || "") === "foreign_corporate") {
    const bo = formData?.fcBeneficialOwnership;
    if (isObject(bo) && Array.isArray(bo.owners)) {
      // Normalize owners: remove fully empty rows
      bo.owners = bo.owners.filter((o) => !isEmptyValue(o));
      formData.fcBeneficialOwnership = bo;
    }
  }
  return formData;
}

// ---------------------------
// PDF-specific normalization
// ---------------------------
function buildPersonName(person) {
  const p = person || {};
  const title = prefer(p.title, p.Title);
  const initials = prefer(p.namesByInitials, p["Names By Initials"], p.initials, p.Initials);
  const surname = prefer(p.surname, p.Surname, p.surnames, p.Surnames);

  const parts = [title, initials, surname]
    .map((s) => String(s ?? "").trim())
    .filter(Boolean);

  return parts.join(" ");
}

function buildPersonAddress(person) {
  const p = person || {};
  return prefer(
    p.permanentAddress,
    p["Permanent Address"],
    p.correspondenceAddress,
    p["Correspondence Address"],
    p.residentialAddress,
    p["Residential Address"],
    p.officeAddress,
    p["Office Address"]
  );
}

function normalizeFormDataForPdf(formKey, formData) {
  const out = cloneJson(formData || {});

  // Fix the known Local Individual mismatches between UI and PDF:
  // 1) "Declaration" contains staff/authorized/office-use fields but UI treats them as part of Client Registration.
  // 2) UI captures Parties fields inside Client Registration, not inside step.parties arrays.
  if (String(formKey || "") === "local_individual") {
    const cr = out.clientRegistration || {};
    const decl = out.declaration || {};

    // Move office-use fields from Declaration -> Client Registration (PDF only)
    const moved = {
      staffName: decl?.staffName,
      authorizedPersonsName: decl?.authorizedPersonsName,
      authorizedPersonsNic: decl?.authorizedPersonsNic,
      officeUseOnly: decl?.officeUseOnly,
    };

    // Put them under a clear group so they don't appear under Declaration in the PDF.
    cr.officeUse = {
      staffName: moved.staffName,
      authorizedPersonsName: moved.authorizedPersonsName,
      authorizedPersonsNic: moved.authorizedPersonsNic,
      ...(isObject(moved.officeUseOnly) ? moved.officeUseOnly : {}),
    };

    // Remove from Declaration to prevent wrong-step display
    if (isObject(decl)) {
      delete decl.staffName;
      delete decl.authorizedPersonsName;
      delete decl.authorizedPersonsNic;
      delete decl.officeUseOnly;
    }

    // Build parties (Principal / Joint1 / Joint2) from Client Registration
    const principal = cr?.principal || {};
    const joint1 = cr?.jointApplicant || {};
    const joint2 = cr?.secondJointApplicant || {};

    const party1 = {
      name: buildPersonName(principal),
      nicNo: prefer(principal?.nic, principal?.Nic),
      address: buildPersonAddress(principal),
    };
    const party2 = (joint1?.enabled || joint1?.Enabled)
      ? {
          name: buildPersonName(joint1),
          nicNo: prefer(joint1?.nic, joint1?.Nic),
          address: buildPersonAddress(joint1),
        }
      : { name: "", nicNo: "", address: "" };
    const party3 = (joint2?.enabled || joint2?.Enabled)
      ? {
          name: buildPersonName(joint2),
          nicNo: prefer(joint2?.nic, joint2?.Nic),
          address: buildPersonAddress(joint2),
        }
      : { name: "", nicNo: "", address: "" };

    // Overwrite parties arrays because the UI does not write to them;
    // otherwise PDFs show blanks or incorrect values.
    ["clientAgreement", "creditFacility", "paymentInstruction", "directionOnline"].forEach((k) => {
      const step = out?.[k];
      if (isObject(step) && Array.isArray(step.parties)) {
        step.parties = [party1, party2, party3];
        out[k] = step;
      }
    });

    out.clientRegistration = cr;
    out.declaration = decl;
  }

  return out;
}

// Step order MUST match the UI wizard configs.
function getStepDefinitions(formKey) {
  switch (String(formKey || "")) {
    case "local_individual":
      return [
        { key: "clientRegistration", title: "Client Registration" },
        { key: "declaration", title: "Declaration" },
        { key: "clientAgreement", title: "Client Agreement" },
        { key: "creditFacility", title: "Agreement - Credit Facility" },
        { key: "paymentInstruction", title: "Payment Instruction" },
        { key: "directionOnline", title: "Direction Online Form" },
      ];
    case "local_corporate":
      return [
        { key: "clientRegistration", title: "Client Registration" },
        { key: "creditFacility", title: "Agreement - Credit Facility" },
        { key: "paymentInstruction", title: "Payment Instructions" },
        { key: "kyc", title: "KYC Form" },
        { key: "beneficialOwnership", title: "Beneficial Ownership Form" },
        { key: "additionalRequirements", title: "Additional Requirements" },
      ];
    case "foreign_individual":
      return [
        { key: "fiClientRegistration", title: "Client Registration" },
        { key: "fiDeclaration", title: "Declaration" },
        { key: "fiClientAgreement", title: "Client Agreement" },
        { key: "fiDirectionOnline", title: "DirectFN Online Form" },
      ];
    case "foreign_corporate":
      return [
        { key: "fcClientRegistration", title: "Client Registration" },
        { key: "fcKyc", title: "KYC Form" },
        { key: "fcBeneficialOwnership", title: "Beneficial Ownership Form" },
        { key: "fcAdditionalRequirements", title: "Additional Requirements" },
      ];
    default:
      return [];
  }
}


function renderForeignCorporateBeneficialOwnership(doc, data) {
  const v = data || {};
  // Owners table (fixed columns)
  const owners = Array.isArray(v.owners) ? v.owners.filter((o) => o && typeof o === 'object') : [];
  if (owners.length) {
    addTable(
      doc,
      'Beneficial Owners',
      owners,
      [
        { key: 'name', label: 'Name' },
        { key: 'nicOrPassport', label: 'NIC / Passport' },
        { key: 'dob', label: 'DOB' },
        { key: 'currentAddress', label: 'Current Address' },
      ]
    );

    // Extra fields per owner (kept structured, not cramped in table)
    owners.forEach((o, idx) => {
      const hasExtras = !isEmptyValue(o.sourceOfBeneficialOwnership) || !isEmptyValue(o.pep);
      if (!hasExtras) return;
      drawSectionCard(doc, `Owner #${idx + 1} - Additional Info`);
      const shade = { v: false };
      if (!isEmptyValue(o.sourceOfBeneficialOwnership)) {
        addKeyValueRow(doc, 'Source Of Beneficial Ownership', o.sourceOfBeneficialOwnership, { shade: (shade.v = !shade.v) });
      }
      if (!isEmptyValue(o.pep)) {
        addKeyValueRow(doc, 'PEP', o.pep, { shade: (shade.v = !shade.v) });
      }
      doc.moveDown(0.25);
    });
  }

  // Other blocks
  const rest = {
    authorizedCustomer: v.authorizedCustomer,
    verificationText: v.verificationText,
    afiOfficial: v.afiOfficial,
    appendix: v.appendix,
    declaration: v.declaration,
    notes: v.notes,
  };

  Object.entries(rest).forEach(([k, val]) => {
    if (isEmptyValue(val)) return;
    writeAnyPretty(doc, k, val, 0, { v: false });
  });
}

function renderForeignIndividualClientRegistration(doc, data) {
  const v = data || {};
  // Keep the same structure as UI: Principal, Local Bank Contact, Joint Applicants, Instructions, Office Use
  const order = [
    ['principal', 'Principal'],
    ['localBankContact', 'Local Bank Contact'],
    ['jointApplicant', 'Joint Applicant'],
    ['secondJointApplicant', 'Second Joint Applicant'],
    ['jointCdsInstructions', 'Joint CDS Instructions'],
    ['officeUseOnly', 'Office Use Only'],
  ];

  order.forEach(([key, title]) => {
    const block = v?.[key] ?? v?.[titleCase(key)] ?? undefined;
    if (isEmptyValue(block)) return;
    drawSectionCard(doc, title);
    if (isObject(block)) {
      const shade = { v: false };
      Object.entries(block).forEach(([k, val]) => {
        if (isEmptyValue(val)) return;
        writeAnyPretty(doc, k, val, 0, shade);
      });
    } else {
      addKeyValueRow(doc, title, block, { shade: true });
    }
    doc.moveDown(0.25);
  });

  // Any remaining keys
  const known = new Set(order.map(([k]) => k));
  Object.entries(v).forEach(([k, val]) => {
    if (known.has(k)) return;
    if (isEmptyValue(val)) return;
    writeAnyPretty(doc, k, val, 0, { v: false });
  });
}

function pickStepData(formData, def) {
  if (!formData || !def) return undefined;
  // Support possible title-cased keys in persisted docs (older versions)
  const candidates = [def.key, titleCase(def.key), def.title];
  for (const k of candidates) {
    if (k in formData) return formData[k];
  }
  return undefined;
}

function drawSectionCard(doc, title) {
  const x = doc.page.margins.left;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  // Section title
  ensureSpace(doc, 28);
  doc.save();
  doc.fillColor("#0f172a").font("Helvetica-Bold").fontSize(12).text(title, x, doc.y, {
    width: w,
    align: "left",
  });
  doc.restore();

  doc.moveDown(0.4);

  // light background line
  doc.save();
  doc.moveTo(x, doc.y).lineTo(x + w, doc.y).strokeColor("#E2E8F0").stroke();
  doc.restore();

  doc.moveDown(0.6);
}

function addKeyValueRow(doc, label, value, opts = {}) {
  const x = doc.page.margins.left + (opts.indent || 0);
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right - (opts.indent || 0);
  const labelW = Math.min(190, Math.floor(w * 0.38));
  const gap = 10;
  const valueW = w - labelW - gap;

  const k = titleCase(label);
  const v = formatValue(value);

  doc.fontSize(10);

  // Calculate height by measuring wrapped text
  doc.font("Helvetica-Bold");
  const labelH = doc.heightOfString(k, { width: labelW });
  doc.font("Helvetica");
  const valueH = doc.heightOfString(v, { width: valueW });

  const rowH = Math.max(labelH, valueH) + 6;
  ensureSpace(doc, rowH + 4);

  const y = doc.y;

  // Row background (alternating)
  if (opts.shade) {
    doc.save();
    doc.rect(x, y - 2, w, rowH).fill("#F8FAFC");
    doc.restore();
  }

  doc.fillColor("#334155").font("Helvetica-Bold").text(k, x + 6, y, { width: labelW - 6 });
  doc.fillColor("#0f172a").font("Helvetica").text(v, x + labelW + gap, y, { width: valueW });

  doc.y = y + rowH;
}

function addBulletList(doc, items, indent = 0) {
  const x = doc.page.margins.left + indent;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right - indent;
  if (!items || items.length === 0) {
    addKeyValueRow(doc, "Items", "-", { indent });
    return;
  }

  items.forEach((it) => {
    ensureSpace(doc, 16);
    doc.fillColor("#0f172a").font("Helvetica").fontSize(10);
    doc.text(`â€¢ ${formatValue(it)}`, x, doc.y, { width: w });
    doc.moveDown(0.15);
  });
}

function addTable(doc, title, rows, columns) {
  const x = doc.page.margins.left;
  const w = doc.page.width - doc.page.margins.left - doc.page.margins.right;

  ensureSpace(doc, 60);
  doc.fillColor("#0f172a").font("Helvetica-Bold").fontSize(11).text(title, x, doc.y, { width: w });
  doc.moveDown(0.35);

  const colCount = columns.length;
  const colW = w / colCount;
  const headerH = 18;

  // header background
  doc.save();
  doc.rect(x, doc.y, w, headerH).fill("#E2E8F0");
  doc.restore();

  const headerY = doc.y + 4;
  columns.forEach((c, i) => {
    doc.fillColor("#0f172a").font("Helvetica-Bold").fontSize(9);
    doc.text(c.label, x + i * colW + 6, headerY, { width: colW - 12 });
  });

  doc.y = doc.y + headerH;

  rows.forEach((r, idx) => {
    const cells = columns.map((c) => formatValue(r?.[c.key]));

    // compute row height
    doc.font("Helvetica").fontSize(9);
    const heights = cells.map((t, i) => doc.heightOfString(t, { width: colW - 12 }));
    const rowH = Math.max(...heights, 10) + 8;

    // IMPORTANT:
    // ensureSpace() may add a new page and reset doc.y.
    // We must capture the row's Y position AFTER ensuring space,
    // otherwise we end up drawing rows at the old page's bottom Y,
    // which creates "fragmented" tables across many pages.
    ensureSpace(doc, rowH + 10);

    const y = doc.y;

    if (idx % 2 === 0) {
      doc.save();
      doc.rect(x, y, w, rowH).fill("#F8FAFC");
      doc.restore();
    }

    // borders
    doc.save();
    doc.rect(x, y, w, rowH).strokeColor("#CBD5E1").stroke();
    for (let i = 1; i < colCount; i++) {
      doc.moveTo(x + i * colW, y).lineTo(x + i * colW, y + rowH).strokeColor("#CBD5E1").stroke();
    }
    doc.restore();

    columns.forEach((c, i) => {
      doc.fillColor("#0f172a").font("Helvetica").fontSize(9);
      doc.text(cells[i], x + i * colW + 6, y + 4, { width: colW - 12 });
    });

    doc.y = y + rowH;
  });

  doc.moveDown(0.6);
}

function writeAnyPretty(doc, key, value, indent = 0, shadeToggle = { v: false }) {
  if (isEmptyValue(value)) return;
  if (Array.isArray(value)) {
    // If array of objects -> render table (best effort)
    const objItems = value.filter(isObject);
    const primitiveItems = value.filter((v) => !isObject(v));

    if (objItems.length > 0) {
      // Choose columns from union of keys (limited)
      const keySet = new Set();
      objItems.forEach((o) => Object.keys(o || {}).forEach((k) => keySet.add(k)));
      const cols = Array.from(keySet).slice(0, 5).map((k) => ({ key: k, label: titleCase(k) }));
      addTable(doc, titleCase(key), objItems, cols);
      if (primitiveItems.length > 0) {
        addBulletList(doc, primitiveItems.map(formatValue), indent + 10);
      }
      return;
    }

    // Primitive list
    doc.fillColor("#334155").font("Helvetica-Bold").fontSize(10);
    doc.text(`${titleCase(key)}:`, doc.page.margins.left + indent);
    doc.moveDown(0.2);
    addBulletList(doc, value, indent + 10);
    doc.moveDown(0.2);
    return;
  }

  if (isObject(value)) {
    drawSectionCard(doc, titleCase(key));
    const entries = Object.entries(value);
    if (entries.length === 0) {
      addKeyValueRow(doc, "Value", "-", { indent, shade: (shadeToggle.v = !shadeToggle.v) });
      doc.moveDown(0.15);
      return;
    }

    entries.forEach(([k, v]) => {
      writeAnyPretty(doc, k, v, indent, shadeToggle);
    });

    doc.moveDown(0.4);
    return;
  }

  addKeyValueRow(doc, key, value, { indent, shade: (shadeToggle.v = !shadeToggle.v) });
  doc.moveDown(0.05);
}

export async function buildApplicationPdfBuffer(appDoc) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ size: "A4", margin: 46, bufferPages: true });
      const chunks = [];
      doc.on("data", (c) => chunks.push(c));
      doc.on("end", () => resolve(Buffer.concat(chunks)));

      const submittedAt = new Date(appDoc.createdAt || Date.now());
      const title = "Application Submission";
      const subtitleLeft = `Submission ID: ${String(appDoc._id)}`;
      const subtitleRight = `Submitted: ${submittedAt.toLocaleString()}`;

      drawHeader(doc, { title, subtitleLeft, subtitleRight });

      // Quick meta block
      drawSectionCard(doc, "Application Summary");
      const shadeToggle = { v: false };
      addKeyValueRow(doc, "Region", appDoc.region, { shade: (shadeToggle.v = !shadeToggle.v) });
      addKeyValueRow(doc, "Applicant Type", appDoc.applicantType, { shade: (shadeToggle.v = !shadeToggle.v) });
      addKeyValueRow(doc, "Form Key", appDoc.formKey, { shade: (shadeToggle.v = !shadeToggle.v) });
      doc.moveDown(0.6);

      // Form details (render strictly in the same order as the UI wizard steps)
      const hydratedFormData = hydrateAutofillFields(appDoc);
      const pdfFormData = normalizeFormDataForPdf(appDoc?.formKey, hydratedFormData);
      drawSectionCard(doc, "Form Details");

      const shadeToggle2 = { v: false };
      const stepDefs = getStepDefinitions(appDoc?.formKey);

      // Render known steps in order
      
      stepDefs.forEach((def, idx) => {
        const v = pickStepData(pdfFormData, def);
        drawStepHeader(doc, idx + 1, def.title || titleCase(def.key));

        const fk = String(appDoc?.formKey || "");
        if (fk === "foreign_corporate" && def.key === "fcBeneficialOwnership" && isObject(v)) {
          renderForeignCorporateBeneficialOwnership(doc, v);
        } else if (fk === "foreign_individual" && def.key === "fiClientRegistration" && isObject(v)) {
          renderForeignIndividualClientRegistration(doc, v);
        } else {
          if (isObject(v)) {
            const innerEntries = Object.entries(v).filter(([_, val]) => !isEmptyValue(val));
            if (innerEntries.length === 0) {
              addKeyValueRow(doc, "Value", "-", { shade: (shadeToggle2.v = !shadeToggle2.v) });
            } else {
              innerEntries.forEach(([ik, iv]) => writeAnyPretty(doc, ik, iv, 0, shadeToggle2));
            }
          } else if (Array.isArray(v)) {
            writeAnyPretty(doc, def.key, v, 0, shadeToggle2);
          } else if (!isEmptyValue(v)) {
            addKeyValueRow(doc, def.key, v, { shade: (shadeToggle2.v = !shadeToggle2.v) });
          } else {
            addKeyValueRow(doc, def.key, "-", { shade: (shadeToggle2.v = !shadeToggle2.v) });
          }
        }

        doc.moveDown(0.35);
      });

      // IMPORTANT:
      // Render ONLY the known UI steps for the selected form.
      // Some client states may include keys from other forms; we must not print them,
      // otherwise users see extra "STEP" blocks (e.g., Foreign Corporate incorrectly showing 5 steps).
      // If you ever need debugging output, you can enable it with PDF_INCLUDE_EXTRAS=true.
      const INCLUDE_EXTRAS = String(process.env.PDF_INCLUDE_EXTRAS || "false").toLowerCase() === "true";
      if (INCLUDE_EXTRAS) {
        const known = new Set(stepDefs.map((d) => d.key));
        const extras = Object.keys(pdfFormData || {}).filter((k) => !known.has(k));
        if (extras.length > 0) {
          drawStepHeader(doc, stepDefs.length + 1, "Additional Data");
          extras.forEach((k) => writeAnyPretty(doc, k, pdfFormData[k], 0, shadeToggle2));
          doc.moveDown(0.35);
        }
      }

      // Add footers to all pages
      const range = doc.bufferedPageRange();
      for (let i = 0; i < range.count; i++) {
        doc.switchToPage(i);
        drawFooter(doc, i + 1);
      }

      doc.end();
    } catch (e) {
      reject(e);
    }
  });
}
